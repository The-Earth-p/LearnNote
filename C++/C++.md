# C++学习笔记

## 头文件

#include：编译预处理

![image-20250103134905841](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103134905841.png)

## C++基础

### 命名空间

`namespace` :通过“::”，即双冒号调用命名空间中的成员，`using namespace #空间名称` 一句可以直接引入该命名空间中的全部成员，之后调用无需再添加 `#空间名称::` 这种格式。

C++中cin和cout输出就是提前引入了std这个命名空间，如下

```#include <iostream> ```

```using namespace std;```

### 缺省参数

1.从右往左依次给出

2.不可同时在声明和定义中出现

3.缺省值是常量或全局变量

### 函数重载

函数重载常用来处理实现功能类似，而数据类型不同的问题，这些同名函数的形参列表必须不同：**参数个数、参数类型或者参数顺序不同**

C语言不支持重载

### 引用

给变量起别名，引用类型必须和引用实体是同种类型的，注意 `const` 也要同时具有

引用在做函数形参的时候能够起到和指针一样的效果，都能对形参所引用对象或指向的地址有所影响

引用还可以做返回值，但是返回的必须是static修饰或者是动态开辟的或者是全局变量等不会随着函数调用的结束而被销毁的数据

**引用和指针的区别**：
 1、引用在定义时必须初始化，指针没有要求。
 2、引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体。
 3、没有NULL引用，但有NULL指针。
 4、在sizeof中的含义不同：引用的结果为引用类型的大小，但指针始终是地址空间所占字节个数（32位平台下占4个字节）。
 5、引用进行自增操作就相当于实体增加1，而指针进行自增操作是指针向后偏移一个类型的大小。
 6、有多级指针，但是没有多级引用。
 7、访问实体的方式不同，指针需要显示解引用，而引用是编译器自己处理。
 8、引用比指针使用起来相对更安全

### 内联函数

1、inline是一种以空间换时间的做法，省了去调用函数的额外开销。由于**内联函数会在调用的位置展开**，所以代码很长或者有递归的函数不适宜作为内联函数。频繁调用的小函数建议定义成内联函数。
 2、inline对于编译器而言只是一个建议，编译器会自动优化，如果定义为inline的函数体内有递归等，编译器优化时会忽略掉内联。
 3、inline不建议声明和定义分离，分离会导致链接错误。因为inline被展开，就没有函数地址了链接就会找不到。

### auto关键字（C++11）

使用auto变量时必须对其进行初始化

`#include <iostream>
using namespace std;
double Fun()
{
	return 3.14;
}
int main()
{
	int a = 10;
	auto b = a;
	auto c = 'A';
	auto d = Fun();
	//打印变量b,c,d的类型
	cout << typeid(b).name() << endl;//打印结果为int
	cout << typeid(c).name() << endl;//打印结果为char
	cout << typeid(d).name() << endl;//打印结果为double
	return 0;
}`

1.用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时必须加&

2.auto不能当形参的数据类型，不能直接用来声明数组

### 指针空值

C++11之前，用NULL来当空指针，但是它的值飘忽不定，是0也是void类型的指针，编译器默认是看作一个0的整型常量

![image-20250103151142745](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103151142745.png)

程序本意是想通过Fun(NULL)调用指针版本的Fun(int* p)函数，但是由于NULL被定义为0，Fun(NULL)最终调用的是Fun(int p)函数

C++11引入了nullptr，表示指针空值的时候，就用这个。

## C++类和对象

C语言面向过程：分析求解问题的步骤，通过函数调用逐步解决问题

C++面向对象：将问题拆分成不同对象来完成，靠对象之间的相互作用来解决问题

### 类的定义

C++中结构体也可以加入函数了，也就是class（类）

类有两种定义方式：

1、声明和定义全部放在类体中。需要注意：成员函数如果在类中定义，编译器可能会将其当成**内联函数**处理

![image-20250103151752730](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103151752730.png)

2、声明放在头文件(.h)中，定义放在源文件(.cpp)中（更优）

![image-20250103151826788](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103151826788.png)

### 类的访问限定符及类的封装

![image-20250103153240507](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103153240507.png)

1.public修饰的成员可以在类外直接被访问。
2.protected和private修饰的成员在类外不能直接被访问。
3.访问权限从该访问限定符出现的位置开始直到下一个访问限定符出现时为止。
4.class的默认访问权限为private，struct为public（因为struct要兼容C）

5.不想对外开放的就用 protected/private 封装起来，用 public 封装的成员允许外界对其进行合理的访问

### 类的存储大小

成员变量之和，与成员函数无关,成员函数是存储在公共代码段的

### this指针

一个类定义了两个对象，调用函数的时候如何判断调用的是哪一个对象里的函数呢？

 **C++编译器给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象（函数运行时调用该函数的对象），在函数体中所有成员变量的操作，都是通过该指针去访问的。只不过所有操作对用户是透明的，即用户不需要来传递，而是编译器自动完成**

![image-20250103160334922](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103160334922.png)

**this指针的特性**
1、this指针的类型：类类型* const。
2、this指针只能在“成员函数”的内部使用。
3、this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。
4、this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过ecx寄存器自动传递，不需要用户传递。

深入理解this实例

![image-20250103160607104](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250103160607104.png)

解析：

指针p确实是一个类的空指针，但当执行第一句代码时，程序并不会崩溃。第一句代码并没有对空指针p进行解引用，因为Show等成员函数地址并没有存到对象里面，成员函数的地址是存在公共代码段的。
 当程序执行第二句代码时，会因为内存的非法访问而崩溃。执行第二句代码时，调用了成员函数PrintA，这里并不会产生什么错误（理由同上），但是PrintA函数中打印了成员变量_a，成员变量_a只有通过对this指针进行解引用才能访问到，而this指针此时接收的是nullptr，对空进行解引用必然会导致程序的崩溃

### 类的6个默认成员函数

**构造函数**：名字与类名相同,创建类类型对象时由编译器自动调用，保证每个数据成员都有 一个合适的初始值，并且在对象的生命周期内只调用一次

构造函数不是开空间，而是初始化对象，由编译器在创建时自动调用

**构造函数的特性**
一、构造函数的函数名与类名相同
二、构造函数无返回值
 这里所说的构造函数无返回值是真的无返回值，而不是说返回值为void。
三、对象实例化时编译器自动调用对应的构造函数
 当你用类创建一个对象时，编译器会自动调用该类的构造函数对新创建的变量进行初始化。
四、构造函数支持重载
 这意味着你可以有多种初始化对象的方式，编译器会根据你所传递的参数去调用对应的构造函数。
五、**无参的构造函数、全缺省的构造函数以及我们不写编译器自动生成的构造函数**都称为默认构造函数，并且默认构造函数只能有一个

六、如果类中没有显示定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，若用户显示定义了，则编译器就不再生成

另一种书写方式：初始化列表，对于自定义类型，初始化列表可以提高代码效率

![image-20250104115350978](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104115350978.png)

注意事项：
一、每个成员变量在初始化列表中只能出现一次
 因为初始化只能进行一次，所以同一个成员变量在初始化列表中不能多次出现。
二、类中包含以下成员，必须放在初始化列表进行初始化：
1.引用成员变量
 引用类型的变量在定义时就必须给其一个初始值，同理，引用成员变量必须使用初始化列表对其进行初始化
2.const成员变量
 被const修饰的变量也必须在定义时就给其一个初始值，也必须使用初始化列表进行初始化

三、成员变量在类中**声明的次序**就是其在初始化列表中的初始化顺序，与其在初始化列表中的先后顺序无关



**析构函数**：与构造函数功能相反，析构函数负责完成对象的销毁，对象在销毁时会自动调用析构函数，完成类的一些资源清理工作

**析构函数特性：**

一、析构函数的函数名是在类名前加上字符‘~’

二、析构函数无参数，无返回值
 析构函数所谓的无返回值也是真的无返回值，而不是返回值为void。
三、对象生命周期结束时，C++编译器会自动调用析构函数
 这就大大降低了C语言中栈空间忘记释放问题的发生，因为当栈对象生命周期结束时，C++编译器会自动调用析构函数对其栈空间进行释放。
四、一个类有且只有一个析构函数。若未显示定义系统会自动生成默认的析构函数

五、先构造的后析构，后构造的先析构
 因为对象是定义在函数中的，函数调用会建立栈帧，栈帧中的对象构造和析构也要符合先进后出的原则



**拷贝构造函数**：只有单个形参，该形参是对本类类型对象的引用（一般常用从const修饰），在用已存在的类类型对象创建新对象时由编译器自动调用

![image-20250104104104684](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104104104684.png)

**拷贝构造函数的特性**

一、拷贝构造函数是构造函数的一个重载形式
 因为拷贝构造函数的函数名也与类名相同。
二、拷贝构造函数的参数只有一个且必须使用引用传参，使用传值方式会引发无穷递归调用

****三、编译器自动生成的拷贝构造函数机制：****
 1、编译器自动生成的拷贝构造函数对内置类型会完成浅拷贝（值拷贝）。**
 2、对于自定义类型，编译器会再去调用它们自己的默认拷贝构造函数

浅拷贝：也称为值拷贝，就是内容的完全复制，比如指针的成员的浅拷贝，就会导致两个对象中的指针指的地址空间是完全一致的，在析构的时候会对同一块地址析构两次，从而发生错误



**运算符重载**

运算符重载函数也具有自己的返回值类型，函数名字以及参数列表。其返回值类型和参数列表与普通函数类似，运算符重载函数名为：关键字operator后面接需要重载的操作符符号

**注意：**
 1.不能通过连接其他符号来创建新的操作符：比如operator@。
 2.重载操作符必须有一个类类型或枚举类型的操作数。
 3.用于内置类型的操作符，重载后其含义不能改变。
 4.作为类成员的重载函数时，函数有一个默认的形参this，限定为第一个形参。
 5.sizeof 、:: 、.* 、?: 、. 这5个运算符不能重载

类中的运算符重载

![image-20250104110156464](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104110156464.png)

我们也可以将该运算符重载函数放在类外面，但此时外部无法访问类中的成员变量，这时我们可以将类中的成员变量设置为共有(public)，这样外部就可以访问该类的成员变量了（也可以用友元函数解决该问题）。并且在类外没有this指针，所以此时函数的形参我们必须显示的设置两个。会发现，其实这里不是看作类的一个成员函数了，而是相对于全局的一个函数重载，但是指定了参数列表，对于正常的==号不影响。

![image-20250104110301367](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104110301367.png)



**赋值运算符重载**

![image-20250104112742629](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104112742629.png)

**重载赋值运算符需要注意以下几点：**
一、参数类型设置为引用，并用const进行修饰
 赋值运算符重载函数的第一个形参默认是this指针，第二个形参是我们赋值运算符的右操作数。
 由于是自定义类型传参，我们若是使用传值传参，会额外调用一次拷贝构造函数，所以函数的第二个参数最好使用引用传参（第一个参数是默认的this指针，我们管不了）。
 其次，第二个参数，即赋值运算符的右操作数，我们在函数体内不会对其进行修改，所以最好加上const进行修饰。
二、函数的返回值使用引用返回
 实际上，我们若是只以d2 = d1这种方式使用赋值运算符，赋值运算符重载函数就没必要有返回值，因为在函数体内已经通过this指针对d2进行了修改。但是为了支持连续赋值，即d3 = d2 = d1，我们就需要为函数设置一个返回值了，而且很明显，返回值应该是赋值运算符的左操作数，即this指针指向的对象。
 和使用引用传参的道理一样，为了避免不必要的拷贝，我们最好还是使用引用返回，因为此时出了函数作用域this指针指向的对象并没有被销毁，所以可以使用引用返回。
三、赋值前检查是否是给自己赋值
 若是出现d1 = d1，我们不必进行赋值操作，因为自己赋值给自己是没有必要进行的。所以在进行赋值操作前可以先判断是否是给自己赋值，避免不必要的赋值操作。
四、引用返回的是this
 赋值操作进行完毕时，我们应该返回赋值运算符的左操作数，而在函数体内我们只能通过this指针访问到左操作数，所以要返回左操作数就只能返回this。
五、一个类如果没有显示定义赋值运算符重载，编译器也会自动生成一个，完成对象按字节序的值拷贝
 没错，赋值运算符重载编译器也可以自动生成，并且也是支持连续赋值的。但是编译器自动生成的赋值运算符重载完成的是对象按字节序的值拷贝，例如d2 = d1，编译器会将d1所占内存空间的值完完全全地拷贝到d2的内存空间中去，类似于memcpy。
 对于日期类，编译器自动生成的赋值运算符重载函数就可以满足我们的需求，我们可以不用自己写。但是这也不意味着所有的类都不用我们自己写赋值运算符重载函数，当遇到一些特殊的类，我们还是得自己动手写赋值运算符函数的

对拷贝构造函数和赋值运算符重载做区分，如下

![image-20250104112001046](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104112001046.png)

二三行代码实际上都是做了拷贝构造



**Const成员**

我们将const修饰的类成员函数称之为const成员函数，const修饰类成员函数，实际修饰的是类成员函数隐含的this指针，表明在该成员函数中不能对this指针指向的对象进行修改，举例如下

![image-20250104112346146](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104112346146.png)

![image-20250104112436434](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104112436434.png)

### Static成员

声明为static的类成员称为类的静态成员。用static修饰的成员变量，称之为静态成员变量；用static修饰的成员函数，称之为静态成员函数。**静态成员变量一定要在类外进行初始化**，初始化的时候不能加static关键字，但是务必记住作用域的添加

特性：

一、静态成员为所以类对象所共享，不属于某个具体的对象，每个对象操作的都是同一个静态成员（静态成员存在数据段--操作系统）

二、静态成员函数没有隐藏的this指针，不能访问任何非静态成员

访问公有静态成员变量：

![image-20250104120718707](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104120718707.png)

访问私有成员变量：

![image-20250104120739497](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104120739497.png)

注意：静态成员函数只能调用静态成员变量，非静态成员函数可以调用静态成员变量

C++11中，允许在声明的时候就进行初始化赋值，但这不是初始化，相当于是构造函数中的缺省值

### 友元

**友元函数**：友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字

举例：<<和>>的重载函数，像这种输入输出类型的运算符重载，最好还是使用类外定义，友元函数来帮助他们访问private中的成员变量，而不是直接声明成类的函数

![image-20250104121626531](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104121626531.png)

**友元函数说明**：
 1、友元函数可以访问类是私有和保护成员，但不是类的成员函数。
 2、友元函数不能用const修饰。
 3、友元函数可以在类定义的任何地方声明，不受访问限定符的限制。
 4、一个函数可以是多个类的友元函数。
 5、友元函数的调用与普通函数的调用原理相同

**友元类**

如图：

![image-20250104122049436](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104122049436.png)

A声明了B是A的朋友，所以B可以尽情使用A的非公有成员，而B没说A是B的朋友，因此A不能用B的非公有成员，友元关系不可传递



## C/C++内存管理

### C语言动态内存管理

动态开辟内存返回的是void*类型的，因此需要强制类型转换，同时要注意是否开辟内存成功

![image-20250104135335712](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104135335712.png)

realloc函数调整动态内存大小的时候会有三种情况：
 1、原地扩。需扩展的空间后方有足够的空间可供扩展，此时，realloc函数直接在原空间后方进行扩展，并返回该内存空间首地址（即原来的首地址）。
 2、异地扩。需扩展的空间后方没有足够的空间可供扩展，此时，realloc函数会在堆区中重新找一块满足要求的内存空间，把原空间内的数据拷贝到新空间中，并主动将原空间内存释放（即还给操作系统），返回新内存空间的首地址。
 3、扩充失败。需扩展的空间后方没有足够的空间可供扩展，并且堆区中也没有符合需要开辟的内存大小的空间。结果就是开辟内存失败，返回一个NULL

### C++动态内存管理

C的也能用，新增了new和delete（和free一样），这两个是操作符，C里面用的是函数

new用法举例（返回的就是对应类型指针）：

想初始化就在后面加个 `(数值)`

![image-20250104135733871](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104135733871.png)

想初始化后面加个 `{值，值，值...}`

![image-20250104135749688](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104135749688.png)

注意：申请和释放单个元素的空间，使用new和delete操作符；申请和释放连续的空间，使用new[ ]和delete[ ]



## 模板

### 函数模板

模板格式

![image-20250104141140324](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104141140324.png)

参数列表中的数据类型用T1、T2这种来表示

模板实例化

![image-20250104141249582](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104141249582.png)

使用模板隐式实例化时一般不允许类型转换

![image-20250104141431594](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104141431594.png)

模板函数后面的<>中加入数据类型，会帮传入的参数进行类型强转

模板函数匹配原则：

一、一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数

二、对于非模板函数和同名的函数模板，如果其他条件都相同，在调用时会优先调用非模板函数，而不会从该模板产生出一个实例。如果模板可以产生一个具有更好匹配的函数，那么选择模板

### 类模板

定义格式

![image-20250104141740008](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104141740008.png)

类模板中的成员函数若是放在类外定义时，需要加模板参数列表

![image-20250104141823199](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104141823199.png)

类模板不支持分离编译

### 非类型模板参数

类型参数：就是跟在typename和class后面的那个假名

非类型参数：实例化的时候可以用常量做一个参数，如下

![image-20250104144134753](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250104144134753.png)

size_t表示这个模板中的一个参数，后面跟的N指示它是非类型参数模板

注意：

1. 非类型模板参数只允许使用整型家族，浮点数、类对象以及字符串是不允许作为非类型模板参数的。
2. 非类型的模板参数在编译期就需要确认结果，因为编译器在编译阶段就需要根据传入的非类型模板参数生成对应的类或函数

## IO流

C++标准IO流：

注意cin从键盘获取输入时的输入格式

getline可以直接读取一行，包括空格，只以换行符为分隔，而cin以空格tab换行等等为分隔，读不了字符串间的空格

**C++文件IO流**

![image-20250105102322528](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105102322528.png)

![image-20250105102335157](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105102335157.png)

![image-20250105102349576](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105102349576.png)

二进制形式操作文件：（写入）

![image-20250105103032229](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105103032229.png)

文本形式操作文件：（写入）

![image-20250105103109122](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105103109122.png)

还可用>>和<<来操作文件，和C++从键盘读文件很像

![image-20250105103202296](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105103202296.png)

![image-20250105103212590](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105103212590.png)

## 继承

### 继承定义

类设计层次的复用，它允许程序员在保持原有类特性的基础上进行扩展，增加功能，这样产生新的类，称为派生类

定义格式：

![image-20250105104223034](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105104223034.png)

继承方式也有三种，和访问限定符一样的三种，以下是不同继承方式后父类的成员在子类中的访问限定符的限制

![image-20250105104321107](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105104321107.png)

限制规则：

1. 在基类当中的访问方式为public或protected的成员，在派生类当中的访问方式变为：Min(成员在基类的访问方式，继承方式)。
2. 在基类当中的访问方式为private的成员，在派生类当中都是不可见的（派生类在类内类外都不能够访问）
3. protected能让基类成员在子类类内进行访问

class默认private继承，struct默认public继承

### 基类和派生类对象赋值转换

切片/切割：把派生类中基类那部分切来赋值过去

![image-20250105105211296](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105105211296.png)

基类指针可以指向派生类

基类对象不能赋值给派生类对象，基类的指针可以通过强制类型转换赋值给派生类的指针，但是此时基类的指针必须是指向派生类的对象才是安全的

![image-20250105105240997](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105105240997.png)

基类引用可以用派生类来赋值

![image-20250105105306960](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105105306960.png)

### 继承中的作用域

若子类和父类中有同名成员，子类成员将屏蔽父类对同名成员的直接访问，这种情况叫隐藏，也叫重定义

![image-20250105105522919](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105105522919.png)

父子中都有_num这一成员，但是子类最终实例化后， _num的值是子类中声明的初值999，若真要访问父类中的这一成员，就加上作用域限定符person::

派生类的默认成员函数

一般是用初始化列表配合父类默认成员函数实现子类的默认成员函数，但是需要额外加上子类中新定义的成员

派生类与普通类的默认成员函数的不同之处概括为以下几点：

1 派生类的构造函数被调用时，会自动调用基类的构造函数初始化基类的那一部分成员，如果基类当中没有默认的构造函数，则必须在派生类构造函数的初始化列表当中显示调用基类的构造函数。
2 派生类的拷贝构造函数必须调用基类的拷贝构造函数完成基类成员的拷贝构造。
3 派生类的赋值运算符重载函数必须调用基类的赋值运算符重载函数完成基类成员的赋值。
4 派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。
5 派生类对象初始化时，会先调用基类的构造函数再调用派生类的构造函数。
6 派生类对象在析构时，会先调用派生类的析构函数再调用基类的析构函数。

在编写派生类的默认成员函数时，需要注意以下几点：

1 派生类和基类的赋值运算符重载函数因为函数名相同构成隐藏，因此在派生类当中调用基类的赋值运算符重载函数时，需要使用作用域限定符进行指定调用。
2 由于多态的某些原因，任何类的析构函数名都会被统一处理为destructor();。因此，派生类和基类的析构函数也会因为函数名相同构成隐藏，若是我们需要在某处调用基类的析构函数，那么就要使用作用域限定符进行指定调用。
3 在派生类的拷贝构造函数和operator=当中调用基类的拷贝构造函数和operator=的传参方式是一个切片行为，都是将派生类对象直接赋值给基类的引用

父类子类公用同一个静态成员，友元是不继承的

### 菱形虚拟继承

用来解决数据冗余问题和二义性

![image-20250105112256022](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105112256022.png)

B和C中都有A的一个成员属性，采用虚拟继承，能够让D在继承这两个的时候把那个相同的成员属性放到一个指针里去

![image-20250105112420966](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250105112420966.png)

## 多态

### 多态定义

函数调用的多种形态，让不同对象完成同一件事

不同继承关系的类对象，去调用同一函数，产生了不同的行为。在继承中要想构成多态需要满足两个条件：

1. 必须通过基类的指针或者引用  调用虚函数。
2. 被调用的函数必须是虚函数，且派生类**必须**对基类的虚函数进行重写

虚函数：用virtual来修饰的类成员函数

![image-20250106144511100](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106144511100.png)

需要注意的是：

1.只有类的非静态成员函数前可以加virtual，普通函数前不能加virtual。
2.虚函数这里的virtual和虚继承中的virtual是同一个关键字，但是它们之间**没有任何关系**。虚函数这里的virtual是为了实现多态，而虚继承的virtual是为了解决菱形继承的数据冗余和二义性

### 虚函数重写：

![image-20250106145133377](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106145133377.png)

上面的代码中，实现了虚函数的继承，现在可以用父类定义的指针或者引用，来指向子类的对象，并调用虚函数，即可实现子类各自重定义的虚函数，如下：

![image-20250106145313097](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106145313097.png)

注意：子类重写的时候，最好还是加上virtual的修饰

### override和final

final：用这个修饰虚函数，表示虚函数不可重写

override：检查有没有重写基类的虚函数

![image-20250106145917418](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106145917418.png)

重写和重定义就是类的继承相关知识，重载和运算符成员函数等等挂钩

### 抽象类

在虚函数的后面写上=0，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象，如

![image-20250106150123839](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106150123839.png)

派生类继承抽象类后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象

![image-20250106150149218](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106150149218.png)

1. 抽象类可以更好的去表示现实世界中，没有实例对象对应的抽象类型，比如：植物、人、动物等。
2. 抽象类很好的体现了虚函数的继承是一种接口继承，强制子类去重写纯虚函数，因为子类若是不重写从父类继承下来的纯虚函数，那么子类也是抽象类也不能实例化出对象

## 异常

try：防止可能抛出异常的代码，执行这段代码进行异常错误检测

catch：在这个块中定义出现错误时要执行的代码块

### 异常抛出和捕获匹配原则

1 异常是通过抛出对象而引发的，该对象的类型决定了应该激活哪个catch的处理代码，如果抛出的异常对象没有捕获，或是没有匹配类型的捕获，那么程序会终止报错。
2 被选中的处理代码（catch块）是调用链中与该对象类型匹配且离抛出异常位置最近的那一个。
3 抛出异常对象后，会生成一个异常对象的拷贝，因为抛出的异常对象可能是一个临时对象，所以会生成一个拷贝对象，这个拷贝的临时对象会在被catch以后销毁。（类似于函数的传值返回）
4 catch(...)可以捕获任意类型的异常，但捕获后无法知道异常错误是什么。
5 实际异常的抛出和捕获的匹配原则有个例外，捕获和抛出的异常类型并不一定要完全匹配，可以抛出派生类对象，使用基类进行捕获



函数调用链：

1 当异常被抛出后，首先检查throw本身是否在try块内部，如果在则查找匹配的catch语句，如果有匹配的，则跳到catch的地方进行处理。
2 如果当前函数栈没有匹配的catch则退出当前函数栈，继续在上一个调用函数栈中进行查找匹配的catch。找到匹配的catch子句并处理以后，会沿着catch子句后面继续执行，而不会跳回到原来抛异常的地方。
3 如果到达main函数的栈，依旧没有找到匹配的catch，则终止程序

如下代码段：

![image-20250106152753282](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106152753282.png)

func1里面抛出了异常，在try中不断的调用函数，从func3到func1，func1里面发现抛出了异常，但是不在try块中，故返回上一级函数去找，func2中也没有，返回func3去找，func3也没有，回到main中，发现在try中，且有相对应的catch块接收抛出的字符串，如下

![image-20250106153042010](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106153042010.png)

catch(...)可以捕获任意类型异常，但是不知异常具体类型

上述这种迭代链的过程，若中间的某一环节，开辟了新空间，需要在函数执行结束后释放，但是我们在func1抛出异常之后，是会直接终止其他的代码而只对异常进行操作判定，因此可能导致内存无法及时释放，造成内存泄漏，因此我们可以在有生成新空间的函数中，也写一个try和catch(...)，通过在catch中释放了内存之后，再调用 `throw` 函数，进行 **异常的再抛出**

### 异常安全

1 构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化。
2 析构函数主要完成对象资源的清理，最好不要在析构函数中抛出异常，否则可能导致资源泄露（内存泄露、句柄未关闭等）。
3 C++中异常经常会导致资源泄露的问题，比如在new和delete中抛出异常，导致内存泄露，在lock和unlock之间抛出异常导致死锁，C++经常使用RAII的方式来解决以上问题

### 异常规范

为了让函数使用者知道某个函数可能抛出哪些类型的异常，C++标准规定：

1 在函数的后面接throw(type1, type2, ...)，列出这个函数可能抛掷的所有异常类型。
2 在函数的后面接throw()或noexcept（C++11），表示该函数不抛异常。
3 若无异常接口声明，则此函数可以抛掷任何类型的异常。（异常接口声明不是强制的

![image-20250106153949175](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106153949175.png)

### 自定义异常体系

都有一个基类，其他任何的异常类都要在这个基类上进行扩展。一般基类里面会有一个虚函数，供其子类继承重写，如：

基类

![image-20250106154308401](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106154308401.png)

子类：

![image-20250106154345338](C:\Users\Only one\AppData\Roaming\Typora\typora-user-images\image-20250106154345338.png)

C++也有自己的标准库异常体系，其中exception是所有异常类的父类。
